;;
;; Lexical変数が無限Extentを持つことの確認 (SECD8 より)
;;

(define (make-variable-c)
  (let ((c 0))
    (list
      (lambda () c)
      (lambda () (set! c (+ c 1)))
      (lambda () (set! c (- c 1)))
)))

(let* ((funcs (make-variable-c))
       (get-c (car funcs))
       (inc-c (cadr funcs))
       (dec-c (caddr funcs)))
  (print (get-c))
  (inc-c)
  (print (get-c))
  (dec-c)
  (dec-c)
  (print (get-c))
)
;-> 0
;   1
;   -1

----- Lisp用 -----
(defun make-variable-c ()
  (let ((c 0))
    (list
      (lambda () c)
      (lambda () (setq c (+ c 1)))
      (lambda () (setq c (- c 1)))
)))

(let* ((funcs (make-variable-c))
       (get-c (car funcs))
       (inc-c (cadr funcs))
       (dec-c (caddr funcs)))
  (print (funcall get-c))
  (funcall inc-c)
  (print (funcall get-c))
  (funcall dec-c)
  (funcall dec-c)
  (print (funcall get-c))
)
;-> 0
;   1
;   -1

----- function を使用 -----
(defun make-variable-c () (let ((c 0)) (list (function (lambda () c)) (function (lambda () (setq c (+ c 1)))) (function (lambda () (setq c (- c 1)))))))

----- quote を使用 -----
(1)式
(defun make-variable-c () (let ((c 0)) (list (quote (lambda () c)) (quote (lambda () (setq c (+ c 1)))) (quote (lambda () (setq c (- c 1)))))))

(2)式
(let* ((funcs (make-variable-c)) (get-c (car funcs)) (inc-c (cadr funcs)) (dec-c (caddr funcs))) (print (funcall get-c)) (funcall inc-c) (print (funcall get-c)) (funcall dec-c) (funcall dec-c) (print (funcall get-c)))

残念ながら、CPP_Lisp2 では、無限エクステントは実現できていない。
(1)式 (2)式 の順で実行しても、ローカル変数 c が保存されていないため、
> ((lambda () c))
[str] ((lambda () c)) 
[exp] ((lambda nil c))
Segmentation fault (コアダンプ)
となる。

(setq c 0)
としてグローバル変数 c を確保してから
(1)式 (2)式 と実行すれば、
問題なく動作する。
0
1
-1
[eval] -1

やはりローカル変数 c が保存されていないことがわかる。
